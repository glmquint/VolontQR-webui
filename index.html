<html>
  <head>
    <meta charset="utf-8" />
    <!-- <script src="https://unpkg.com/pdf-lib"></script> -->
    <script src="pdf-lib.min.js"></script>
    <!-- <script src="https://unpkg.com/qrcode-generator"></script> -->
    <script src="qrcode.js"></script>
  </head>

  <body style="margin: 0; padding: 0; font-family: Arial, sans-serif;">
    <div style="display: grid; grid-template-columns: 1fr 2fr; height: 100vh; margin: 0;">
      <div>
        <input type="file" id="file" accept=".pdf" style="width: 100%; box-sizing: border-box; font-family: monospace; font-size: 16px;" />
        <textarea id="msg" style="width: 100%; height: 10%; box-sizing: border-box; font-family: monospace; font-size: 16px;" placeholder="Enter text to generate QR code"></textarea>
        <button id="preview" onclick="update(true)">Preview First Page</button>
        <button id="generate" onclick="update()">Generate All</button>
        <div id="qr" style="opacity: 0"></div>
      </div>
      <iframe id="pdf" style="width: 100%; height: 100%;"></iframe>
    </div>
  </body>

  <script>
    function preCreatePdf() {
      btn = document.getElementById('generate');
      btn.disabled = true;
      btn.innerText = 'Generating...';
    }
    function postCreatePdf() {
      btn = document.getElementById('generate');
      btn.disabled = false;
      btn.innerText = 'Generate All';
    }
    async function createPdf(links, file, preview = false) {
      preCreatePdf();

      const pdfDoc = await PDFLib.PDFDocument.create();
      for (link of links.split('\n')) {
        if (link.trim() === '') continue;
        qr_div = document.getElementById('qr');
        qr_div.innerHTML = create_qrcode(link, 10, 'M', 'Byte', 'UTF-8');
        svg = qr_div.getElementsByTagName('svg')[0];

        width = 350;
        height = 400;
        page = null;
        if (file) {
          const filePdfDoc = await PDFLib.PDFDocument.load(file)
          const [firstPage] = await pdfDoc.copyPages(filePdfDoc, [0]);
          page = await pdfDoc.addPage(firstPage);
          width = firstPage.getWidth();
          height = firstPage.getHeight();
        } else {
          page = await pdfDoc.addPage([width, height]);
        }
        w = svg.getBoundingClientRect().width;
        h = svg.getBoundingClientRect().height;
        // debugLines(pdfDoc, page, width, height, w, h);
        console.log('SVG size:', w, h);
        console.log('Page size:', width, height);
        // page.drawText(link);
        page.moveTo(width/2 - w/2, height/2 - h/2); // (0, 0) is bottom-left corner
        page.drawRectangle({width: w, height: h, color: PDFLib.rgb(1, 1, 1)});
        page.moveTo(width/2 - w/2, height/2 + h/2); // (0, 0) is bottom-left corner
        page.drawSvgPath(svg.getElementsByTagName('path')[0].getAttribute('d'), {color: PDFLib.rgb(0, 0, 0)});
        if (preview) break;
      }
      const pdfDataUri = await pdfDoc.saveAsBase64({ dataUri: true });
      document.getElementById('pdf').src = pdfDataUri;

      postCreatePdf();
    }
    function debugLines(pdfDoc, page, width, height, w, h) {
      // Draw debug lines
      const lineWidth = 0.5;
      const color = PDFLib.rgb(0.8, 0.2, 0.2);
      page.drawLine({
        start: { x: 0, y: 0 },
        end: { x: width, y: height },
        thickness: lineWidth,
        color: PDFLib.rgb(0, 1, 0),
      });
      page.drawLine({
        start: { x: 0, y: height },
        end: { x: width, y: 0 },
        thickness: lineWidth,
        color: color,
      });
      page.drawLine({
        start: { x: width/2 - w/2, y: height/2 + h/2 },
        end: { x: width/2 + w/2, y: height/2 + h/2 },
        thickness: lineWidth,
        color: color,
      });
      page.drawLine({
        start: { x: width/2 - w/2, y: height/2 - h/2 },
        end: { x: width/2 + w/2, y: height/2 - h/2 },
        thickness: lineWidth,
        color: color,
      });
      page.drawLine({
        start: { x: width/2 - w/2, y: height/2 - h/2 },
        end: { x: width/2 - w/2, y: height/2 + h/2 },
        thickness: lineWidth,
        color: color,
      });
      page.drawLine({
        start: { x: width/2 + w/2, y: height/2 - h/2 },
        end: { x: width/2 + w/2, y: height/2 + h/2 },
        thickness: lineWidth,
        color: color,
      });
    }
    function create_qrcode(text, typeNumber, errorCorrectionLevel, mode, mb) {
      qrcode.stringToBytes = qrcode.stringToBytesFuncs[mb];
      var qr = qrcode(typeNumber || 4, errorCorrectionLevel || 'M');
      qr.addData(text, mode);
      qr.make();
      // r = qr.createTableTag();
      r = qr.createSvgTag({ alt: '</svg>puke'});
      // r = qr.createImgTag();
      return r;
    };
    async function update(preview = false) {
      links = document.getElementById('msg').value
      file = document.getElementById('file').files[0];
      if (file) {
        file = await file.arrayBuffer();
      }
      createPdf(links, file, preview);
    }
    update(true); // Initial preview
  </script>
</html>
